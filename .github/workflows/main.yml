name: CI/CD Pipeline
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened]
    paths-ignore:
      - '.github/workflows/**'
  workflow_dispatch:

# Global environment variables
env:
  # API Configuration
  PROJECT_NAME: fastapi-supabase
  API_V1_STR: /api/v1
  SECRET_KEY: ${{ secrets.SECRET_KEY }}

  # Environment Settings
  ENVIRONMENT: test
  BACKEND_CORS_ORIGINS: '["http://localhost:3000", "http://localhost:8000"]'

  # Supabase Configuration
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
  SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
  SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
  SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}

  # Database Configuration
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  POSTGRES_SERVER: ${{ secrets.POSTGRES_SERVER }}
  POSTGRES_PORT: 5432
  POSTGRES_DB: postgres
  DATABASE_URL: postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@${{ secrets.POSTGRES_SERVER }}:5432/postgres

  # Auth Configuration
  FIRST_SUPERUSER: ${{ secrets.FIRST_SUPERUSER }}
  FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}

  CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
  SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
  SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
  SONAR_HOST_URL: https://sonarcloud.io

  # Test Configuration
  PYTEST_ADDOPTS: "--color=yes"
  PYTHON_VERSION: "3.12"

  # Deployment
  # Variables pour les d√©ploiements avec promotion d'images
  STAGING_ENV: staging
  PRODUCTION_ENV: production
  IMAGE_NAME: fastapi-supabase-template
  REGISTRY: ${{ vars.DOCKER_REGISTRY || 'ghcr.io' }}
  
jobs:
  quality:
    name: Lint and Format
    runs-on: ubuntu-latest
    # Add workflows permission at job level
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install pre-commit and mypy
        run: |
          uv pip install pre-commit mypy types-requests types-python-dateutil types-PyYAML --system
          cd backend
          uv sync --python 3.12 --all-extras --dev

      # Single step handling pre-commit process and auto-fix
      - name: Run pre-commit with auto-fix
        if: github.event_name == 'pull_request'
        run: |
          # Run pre-commit excluding GitHub workflows
          set +e
          pre-commit run --all-files --exclude='.github/workflows/.*'
          pre_commit_status=$?
          set -e

          # If changes were made
          if [ $pre_commit_status -eq 1 ]; then
            echo "Pre-commit fixed formatting issues. Committing changes..."

            # Configure Git
            git config --local user.email "actions@github.com"
            git config --local user.name "GitHub Actions"

            # Commit and push
            git add -A
            git commit -m "[STYLE] Automatic formatting fix (pre-commit)"
            git push

            # Log message
            echo "‚úÖ Formatting fixes made and pushed to branch."
          else
            echo "‚úÖ No formatting issues detected."
          fi

      # For direct pushes (non PR), just check without auto-fix
      - name: Run pre-commit checks only
        if: github.event_name != 'pull_request'
        run: pre-commit run --all-files --exclude='.github/workflows/.*'

  security:
    name: Security Checks
    runs-on: ubuntu-latest
    needs: quality
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      
      - name: Install security tools
        run: |
          python -m pip install --upgrade pip
          pip install bandit safety
      
      - name: Run Bandit (Python security linter)
        run: |
          bandit -r backend/ -ll -ii -f json -o bandit-results.json || true
          echo "Results saved to bandit-results.json"
      
      - name: Check dependencies for vulnerabilities with Safety
        run: |
          cd backend
          safety check --full-report --file=pyproject.toml || true
      
      - name: Check for secrets in code
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
      
      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: |
            bandit-results.json
            gitleaks-report.json
          retention-days: 7

  dependabot:
    name: Dependabot Auto-Merge
    runs-on: ubuntu-latest
    needs: quality
    if: ${{ github.actor == 'dependabot[bot]' }}
    permissions:
      contents: write
      pull-requests: write
      issues: write
      repository-projects: write
    steps:
      - name: GitHub Actions Dependencies
        if: ${{ contains(github.event.pull_request.labels.*.name, 'github_actions') }}
        run: gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}

      - name: Approve Patch and Minor Updates
        if: ${{ !contains(github.event.pull_request.title, 'bump') || contains(github.event.pull_request.title, '‚¨ÜÔ∏è') }}
        run: |
          # Only automatically process minor and patch updates
          if echo "$PR_TITLE" | grep -E '(patch|minor)'; then
            echo "Approving PR automatically as it's a patch or minor update"
            gh pr review "$PR_URL" --approve -b "Automatically approved as this is a minor or patch update."

            # Only auto-merge if it's not a major update
            if ! echo "$PR_TITLE" | grep -E '(major)'; then
              echo "Setting auto-merge for PR"
              gh pr merge --auto --squash "$PR_URL"
            fi
          else
            echo "Manual review needed for major update"
            gh pr comment "$PR_URL" -b "This major update requires manual review."
          fi
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          PR_TITLE: ${{github.event.pull_request.title}}

  # SonarCloud analysis for code quality
  sonarcloud:
    name: SonarCloud Analysis
    needs: [quality, security]
    runs-on: ubuntu-latest
    # No need to run SonarCloud on PRs from external repositories
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Important for SonarCloud to see complete history

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      # Temporary installation for Supabase verification
      - name: Verify Supabase Connection
        run: |
          python -m pip install python-dotenv httpx
          python backend/scripts/verify_supabase.py

      - name: Build Docker image
        run: docker build --build-arg BUILD_ENV=test -t fastapi-supabase-template:test .

      - name: Run tests with coverage in Docker
        run: |
          docker run \
            -v $(pwd)/.env.test:/app/.env.test \
            -v $(pwd)/backend:/app/backend \
            fastapi-supabase-template:test \
            bash -c "cd /app/backend && python -m pytest -v --cov --junitxml=junit.xml --cov-report=xml -o junit_family=legacy"

      - name: Check coverage threshold
        run: |
          COVERAGE=$(grep -Po 'line-rate="\K[^"]*' backend/coverage.xml | head -1)
          COVERAGE_PCT=$(echo "$COVERAGE * 100" | bc)
          echo "Total coverage: $COVERAGE_PCT%"
          if (( $(echo "$COVERAGE_PCT < 90" | bc -l) )); then
            echo "Code coverage is below the required 90%"
            exit 1
          fi

      # SonarCloud Analysis
      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0

      # Upload coverage reports to Codecov
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./backend/coverage.xml
          fail_ci_if_error: true
          verbose: true

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/test-results-action@v1
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

      # Add comment to PR with coverage report
      - name: Add PR Coverage Comment
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          message: |
            ## Coverage Report
            
            Total coverage: ${{ env.COVERAGE_PCT }}%
            
            <details>
            <summary>Details</summary>
            
            ```
            $(grep -A 20 "<coverage " backend/coverage.xml)
            ```
            </details>

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [sonarcloud]
    # Only build on main branch, develop branch or when it's a tag
    if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/tags/'))
    permissions:
      contents: read
      packages: write
    env:
      IMAGE_TAG: ${{ github.ref == 'refs/heads/main' && 'staging' || github.ref == 'refs/heads/develop' && 'latest' || github.ref_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.repository.created_at }}

  create-sentry-release:
    runs-on: ubuntu-latest
    needs: [build]
    if: startsWith(github.ref, 'refs/tags/') || github.ref == 'refs/heads/main'
    env:
      ENVIRONMENT: ${{ startsWith(github.ref, 'refs/tags/') && 'production' || github.ref == 'refs/heads/main' && 'staging' || 'development' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history to access commits for changelog

      - name: Determine version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          elif [[ $GITHUB_REF == refs/heads/main ]]; then
            VERSION=$(git rev-parse --short HEAD)-staging
          else
            VERSION=$(git rev-parse --short HEAD)-dev
          fi
          echo "release_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version determined: $VERSION"

      - name: Create Sentry Release
        uses: getsentry/action-release@v1
        with:
          auth_token: ${{ secrets.SENTRY_AUTH_TOKEN }}
          org: ${{ secrets.SENTRY_ORG }}
          project: ${{ secrets.SENTRY_PROJECT }}
          environment: ${{ env.ENVIRONMENT }}
          version: ${{ steps.version.outputs.release_version }}
          ignore_missing: true
          ignore_empty: true

  # Deployment √† l'environnement de staging (depuis main)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [create-sentry-release]
    if: github.ref == 'refs/heads/main'
    environment: staging
    steps:
      - name: Deploy to Staging Environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: ${{ secrets.STAGING_SSH_PORT || 22 }}
          script: |
            echo "Deploying to Staging environment..."
            # Se connecter au registre Docker
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            
            # R√©cup√©rer la derni√®re image
            docker pull ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:staging
            
            # D√©ployer avec docker-compose
            cd ${{ secrets.STAGING_APP_PATH }}
            echo "IMAGE_TAG=staging" > .env
            docker-compose pull
            docker-compose up -d
            
            # V√©rifier que l'application fonctionne
            echo "Attente du d√©marrage de l'application..."
            sleep 10
            if curl -s --fail http://localhost:8000/api/v1/health; then
              echo "‚úÖ Application d√©ploy√©e avec succ√®s!"
            else
              echo "‚ùå √âchec du d√©ploiement - l'application ne r√©pond pas."
              exit 1
            fi

  # Deployment (only for version tags)
  release:
    name: Release and Changelog
    needs: [create-sentry-release]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true

      - name: Install dependencies
        run: uv sync --dev

      - name: Generate a changelog
        env:
          ATTICUS_PAT: ${{ secrets.ATTICUS_PAT }}
        run: uv run git-cliff -vv --latest --strip header --github-token "$ATTICUS_PAT" -o CHANGES.md

      - name: Release
        uses: softprops/action-gh-release@v2
        with:
          body_path: CHANGES.md
          token: ${{ secrets.GITHUB_TOKEN }}

  # Deployment en production (uniquement pour les tags)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [release]
    if: startsWith(github.ref, 'refs/tags/')
    environment: production
    steps:
      - name: Get Release Tag
        id: get_tag
        run: echo "RELEASE_TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        
      - name: Deploy to Production Environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || 22 }}
          script: |
            echo "Deploying to Production environment..."
            # Se connecter au registre Docker
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            
            # R√©cup√©rer l'image avec le tag de version
            docker pull ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.get_tag.outputs.RELEASE_TAG }}
            
            # D√©ployer avec docker-compose
            cd ${{ secrets.PRODUCTION_APP_PATH }}
            echo "IMAGE_TAG=${{ steps.get_tag.outputs.RELEASE_TAG }}" > .env
            docker-compose pull
            docker-compose up -d
            
            # V√©rifier que l'application fonctionne
            echo "Attente du d√©marrage de l'application..."
            sleep 10
            if curl -s --fail http://localhost:8000/api/v1/health; then
              echo "‚úÖ Application d√©ploy√©e avec succ√®s!"
            else
              echo "‚ùå √âchec du d√©ploiement - l'application ne r√©pond pas."
              exit 1
            fi

  # D√©ploiement r√©ussi - notification Slack
  notify:
    name: Notification de d√©ploiement
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: Notification Slack
        if: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "üöÄ *D√©ploiement r√©ussi*",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üöÄ *D√©ploiement r√©ussi*"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Application:*\n${{ env.PROJECT_NAME }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Environnement:*\n${{ github.ref == 'refs/heads/main' && 'Staging' || 'Production' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*D√©ploy√© par:*\n${{ github.actor }}"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Voir le workflow",
                        "emoji": true
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK